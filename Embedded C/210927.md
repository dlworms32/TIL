# 임베디드 C
## 1. 어셈블리어의 등장
* 초기 프로그래밍은 CPU 설명서를 보며 2진수로 코딩함
  * 수정 불가
  * 이해가 힘듦 
* 어셈블리어의 등장
  * 2진수 표현 대신 니모닉 기호를 사용해 문자로 표현, 가독성 증가
  * 니모닉 기호 : `10110000`을 `mov`(니모닉 기호)로 표현
  * CPU마다 Instruction Set이 모두 다름
* C언어의 등장
  * 어셈블리어의 단점을 극복
  * 개발자는 CPU의 Instruction Set을 공부하지 않고, C언어만 공부하면 됨
## 2. C언어
* 어셈블리어와 Instruction Set의 차이
  * 기계어냐 심볼이냐 차이밖에 없다.
* 어셈블리어를 알아야 할까?
  * 현재는 개발 환경이 매우 좋아졌기 때문에 상위 수준 어플리케이션을 개발할 경우는 굳이 알 필요는 없다.
* 임베디드에서는 여전히 어셈블리어가 필요하다.
  * 자주 호출하는 특정 C함수를 더 빠른 속도로 구현하고 싶을 때
  * Startup 코드 작성할 때
    * 장치 초기화 신호를 보낼 때
    * C언어 구동에 필요한 메모리(data, stack, heap)를 준비해준다.(부트로더)
  * 디버깅을 할 때, 어셈블리어 수준까지 내려가는 경우도 발생
* Firmware에서 Java를 쓰지 않는 이유
  * 프로세서마다 다르지만, 속도 메모리가 너무 작아서 JRE(Java Runtime Environment)를 구축하기가 매우 어렵다.
* C언어의 단점
  * OOP( Object-Oriented Programming)에 부적합
  * 자유도가 높음(장점이자 단점)
  * 느슨한 규격으로 인해 많은 혼란을 초래함
    * volatile, data type, enum 등
## 3. 진법 변환
* 진수의 입력과 출력
  * scanf 입력
    * 16진수 : `scanf("%x", &[변수명])`
    * 2진수 : `scanf`로 불가능, 문자열로 입력 받은 후, 변환 필요
  * 특정 진수를 10진수로 바꾸는 함수 : `strtol`
    * `stdlib.h`에 정의 
    * 16진수 -> 10진수
        ```c
        char input[16] = "0x38A5";
        // 문자열, 문자열 포인터(보통 NULL), 진법
        int result = strtol(input, NULL, 16); 
        printf("%d\n", result); // 14501
        ```
    * 2진수 -> 10진수
        ```c
        char input[16] = "1001011";
        int result = strtol(input, NULL, 2); 
        printf("%d\n", result); // 75
        ```

## 4. 자료형
* 자료형 : 데이터의 종류를 나타냄 (자료형 == 데이터 타입 == 데이터 형)
* 복잡한 자료형
  * 수학적인 개념과 다름
    * 수학에서 정수는 +, -, * 연산에 대하여 닫혀있지만 프로그래밍 언어는 그렇지 않음
    * 수학에서의 정수 범위 -∞ ~ ∞, 프로그래밍 유한 범위
  * 자료형이 많음
    * `int`, `char`, `float`, `void` ...
  * 수많은 표기법
    * Suffix에 따라 달라짐 (`100 != 100L`)
  * 형 변환시 주의해야함
    * 작은 자료형 -> 큰 자료형
    * 큰 자료형 -> 작은 자료형
    * 양쪽 모두 문제의 소지가 많음
* 변수 이름을 제외하면 변수의 데이터 타입
  ```c
  person a; // a는 person 형
  fan b; // b는 fan 형
  int c; // c는 int 형
  ```
* [참고] 사용자가 정의한 데이터 형은 `_t`(type)를 붙여주자(임베디드 코딩 가이드)
* 생각해보기
  * 메모리에 존재하는 `0x41`은 무엇일까?
    * 값 만으로는 데이터를 설명할 수 없음
    * 데이터 타입을 봐야 함
    * `char` : `'B'` or `0x41` 
    * `int` : 65
  * 메모리에 적힌 `0xFE`는 어떤 의미일까?
    * `unsigned char` : 254
    * `signed char` : -2
* 데이터 형이 많은 이유 
  * 적재 적소에 알맞은 데이터 타입을 쓰기 위함 -> 메모리 효율성 및 연산 속도
  * `char`로도 충분한 경우, `long`처럼 메모리를 많이 차지하는 데이터 타입을 쓸 필요 X